// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package apiPb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// ShortenerClient is the client API for Shortener service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ShortenerClient interface {
	// shortenURL takes url and slug(optional) for request
	// and returns url and slug in response
	ShortenURL(ctx context.Context, in *ShortenURLRequest, opts ...grpc.CallOption) (*ShortenURLResponse, error)
}

type shortenerClient struct {
	cc grpc.ClientConnInterface
}

func NewShortenerClient(cc grpc.ClientConnInterface) ShortenerClient {
	return &shortenerClient{cc}
}

func (c *shortenerClient) ShortenURL(ctx context.Context, in *ShortenURLRequest, opts ...grpc.CallOption) (*ShortenURLResponse, error) {
	out := new(ShortenURLResponse)
	err := c.cc.Invoke(ctx, "/main.Shortener/shortenURL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ShortenerServer is the server API for Shortener service.
// All implementations must embed UnimplementedShortenerServer
// for forward compatibility
type ShortenerServer interface {
	// shortenURL takes url and slug(optional) for request
	// and returns url and slug in response
	ShortenURL(context.Context, *ShortenURLRequest) (*ShortenURLResponse, error)
	mustEmbedUnimplementedShortenerServer()
}

// UnimplementedShortenerServer must be embedded to have forward compatible implementations.
type UnimplementedShortenerServer struct {
}

func (*UnimplementedShortenerServer) ShortenURL(context.Context, *ShortenURLRequest) (*ShortenURLResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShortenURL not implemented")
}
func (*UnimplementedShortenerServer) mustEmbedUnimplementedShortenerServer() {}

func RegisterShortenerServer(s *grpc.Server, srv ShortenerServer) {
	s.RegisterService(&_Shortener_serviceDesc, srv)
}

func _Shortener_ShortenURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShortenURLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShortenerServer).ShortenURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.Shortener/ShortenURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShortenerServer).ShortenURL(ctx, req.(*ShortenURLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Shortener_serviceDesc = grpc.ServiceDesc{
	ServiceName: "main.Shortener",
	HandlerType: (*ShortenerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "shortenURL",
			Handler:    _Shortener_ShortenURL_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

// DatabaseClient is the client API for Database service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DatabaseClient interface {
	// checkIfPresent checks if slug is already present in DB
	// takes slug as request and returns bool as response
	CheckIfPresent(ctx context.Context, in *CheckIfPresentRequest, opts ...grpc.CallOption) (*CheckIfPresentResponse, error)
	// storeInDB stores in Database
	// takes url and slug in request and returns Status
	StoreInDB(ctx context.Context, in *StoreInDBRequest, opts ...grpc.CallOption) (*StoreInDBResponse, error)
	// fetchURLFromSlug takes slug and returns full shortlink
	FetchURLFromSlug(ctx context.Context, in *FetchURLFromSlugRequest, opts ...grpc.CallOption) (*FetchURLFromSlugResponse, error)
}

type databaseClient struct {
	cc grpc.ClientConnInterface
}

func NewDatabaseClient(cc grpc.ClientConnInterface) DatabaseClient {
	return &databaseClient{cc}
}

func (c *databaseClient) CheckIfPresent(ctx context.Context, in *CheckIfPresentRequest, opts ...grpc.CallOption) (*CheckIfPresentResponse, error) {
	out := new(CheckIfPresentResponse)
	err := c.cc.Invoke(ctx, "/main.Database/checkIfPresent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *databaseClient) StoreInDB(ctx context.Context, in *StoreInDBRequest, opts ...grpc.CallOption) (*StoreInDBResponse, error) {
	out := new(StoreInDBResponse)
	err := c.cc.Invoke(ctx, "/main.Database/storeInDB", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *databaseClient) FetchURLFromSlug(ctx context.Context, in *FetchURLFromSlugRequest, opts ...grpc.CallOption) (*FetchURLFromSlugResponse, error) {
	out := new(FetchURLFromSlugResponse)
	err := c.cc.Invoke(ctx, "/main.Database/fetchURLFromSlug", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DatabaseServer is the server API for Database service.
// All implementations must embed UnimplementedDatabaseServer
// for forward compatibility
type DatabaseServer interface {
	// checkIfPresent checks if slug is already present in DB
	// takes slug as request and returns bool as response
	CheckIfPresent(context.Context, *CheckIfPresentRequest) (*CheckIfPresentResponse, error)
	// storeInDB stores in Database
	// takes url and slug in request and returns Status
	StoreInDB(context.Context, *StoreInDBRequest) (*StoreInDBResponse, error)
	// fetchURLFromSlug takes slug and returns full shortlink
	FetchURLFromSlug(context.Context, *FetchURLFromSlugRequest) (*FetchURLFromSlugResponse, error)
	mustEmbedUnimplementedDatabaseServer()
}

// UnimplementedDatabaseServer must be embedded to have forward compatible implementations.
type UnimplementedDatabaseServer struct {
}

func (*UnimplementedDatabaseServer) CheckIfPresent(context.Context, *CheckIfPresentRequest) (*CheckIfPresentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckIfPresent not implemented")
}
func (*UnimplementedDatabaseServer) StoreInDB(context.Context, *StoreInDBRequest) (*StoreInDBResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StoreInDB not implemented")
}
func (*UnimplementedDatabaseServer) FetchURLFromSlug(context.Context, *FetchURLFromSlugRequest) (*FetchURLFromSlugResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FetchURLFromSlug not implemented")
}
func (*UnimplementedDatabaseServer) mustEmbedUnimplementedDatabaseServer() {}

func RegisterDatabaseServer(s *grpc.Server, srv DatabaseServer) {
	s.RegisterService(&_Database_serviceDesc, srv)
}

func _Database_CheckIfPresent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckIfPresentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DatabaseServer).CheckIfPresent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.Database/CheckIfPresent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DatabaseServer).CheckIfPresent(ctx, req.(*CheckIfPresentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Database_StoreInDB_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreInDBRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DatabaseServer).StoreInDB(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.Database/StoreInDB",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DatabaseServer).StoreInDB(ctx, req.(*StoreInDBRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Database_FetchURLFromSlug_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchURLFromSlugRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DatabaseServer).FetchURLFromSlug(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.Database/FetchURLFromSlug",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DatabaseServer).FetchURLFromSlug(ctx, req.(*FetchURLFromSlugRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Database_serviceDesc = grpc.ServiceDesc{
	ServiceName: "main.Database",
	HandlerType: (*DatabaseServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "checkIfPresent",
			Handler:    _Database_CheckIfPresent_Handler,
		},
		{
			MethodName: "storeInDB",
			Handler:    _Database_StoreInDB_Handler,
		},
		{
			MethodName: "fetchURLFromSlug",
			Handler:    _Database_FetchURLFromSlug_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}
